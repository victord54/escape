@startuml
package Escape {
    package Monde {
        enum TypeMouvement{
            RIGHT
            LEFT
            UP
            DOWN
        }

        abstract class ElementMonde {
            # double x
            # double y
            # double hauteur
            # double largeur
            - Type type
            ..Constructeur..
            + ElementMonde(Type, double, double, double, double)
            + ElementMonde(JSONObject)
            ..Méthodes..
            + JSONObject toJSON()
            + {abstract} char getSymbol()
        }

        package Environment {
            abstract class Terrain {
                ..Constructeur..
                + Terrain(Type, double, double, double, double)
                + Terrain(JSONObject)
                ..Méthodes..
                + {static} Terrain fromJSON(JSONObject)
                + boolean estTraversable()
            }

            class Mur extends Terrain {
                ..Constructeur..
                + Mur(double, double, double, double)
                + Mur(JSONObject)
                ..Méthodes..
                + boolean estTraversable()
                + char getSymbol()
            }

            class BordureMonde extends Terrain {
                ..Constructeur..
                + BordureMonde(double, double)
                ..Méthodes..
                + boolean estTraversable()
                + char getSymbol()
            }
        }

        package Entities {
            abstract class Personnage {
                # int id
                # double vitesse
                # double coeurs
                # double coeursMax
                # boolean isMoving
                ..Constructeur..
                + Personnage(Type, double, double, double, double, double, double, double, int)
                + Personnage(JSONObject)
                ..Méthodes..
                + {static} Personnage fromJSON(JSONObject)
                + JSONObject toJSON()
                + void deplacer(TypeMouvement, double)
                + void attaquer(List<Personnage>)
                + Rectangle2D getHitboxAttaque()
                + Rectangle2D getHitboxCollision()
                + boolean estUnHeros()
                + boolean estVivant()
                + void coeursPerdu(double)
                + void coeursGagne(double)
                + {abstract} Personnage clone()
                + boolean boolean peutTraverserObstacles()
            }

            class Heros extends Personnage {
                ..Constructeur..
                + Heros(double, double, double, double, double, double, double, int)
                + Heros(double, double, double, double, double, double, double, int, boolean)
                + Heros(JSONObject)
                ..Méthodes..
                + boolean estUnHeros()
                - void setSprites()
                + char getSymbol()
            }

            abstract class Monstre extends Personnage {
                # ArrayList<TypeMouvement> derniersMouvementsEssayes
                ..Constructeur..
                + Monstre(Type, double, double, double, double, double, double, double, int)
                + Monstre(JSONObject)
                + void reinitialiseListMouvementsEssayes()
                + boolean mouvementDansList(TypeMouvement)
            }

            class Walker extends Monstre {
                ..Constructeur..
                + Walker(double, double, double, double, double, double, double, int)
                + Walker(double, double, double, double, double, double, double, int, boolean)
                + Walker(JSONObject)
                ..Méthodes..
                + char getSymbol()
                - void setSprites()
            }

            class Fantome extends Monstre {
              ..Constructeur..
              + Fantome(double, double, double, double, double, double, double, double, int)
              + Fantome(JSONObject)
              ..Méthodes..
               + char getSymbol()
               - void setSprites()
               + boolean peutTraverserObstacles()
            }
        }
        package Objects {
            abstract class Objet {
                # boolean visible
                ..Constructeur..
                + Objet(Type, double, double, double, double, boolean)
                + Objet(JSONObject)
                ..Méthodes..
                + {abstract} void consommePar(Personnage p);
                + boolean estRamassable()
                + boolean estConsommable()
                + boolean estDeclenchable()
                + boolean estCoeur()
                + boolean estPiege()
            }

            class Coeur extends Objet {
                # double valeur
                ..Constructeur..
                + Coeur(double, double, double, double, double)
                + Coeur(JSONObject)
                ..Méthodes..
                + char getSymbol()
                + void consommePar(Personnage)
                + boolean estCoeur()
            }

            class Piege extends Objet{
                # double degats
                ..Constructeur..
                + Piege(double, double, double, double, double)
                + Piege(JSONObject json)
                ..Méthodes..
                + boolean estDeclenchable()
                + void consommePar(Personnage p)
                + boolean estPiege()
                + char getSymbol()

            }
        }

        class Monde {
            ..Constructeur..
            + Monde()
            ..Méthodes..
            + {static} Monde fromMap(String)
            + {static} Monde fromJSON(JSONObject)
            + {static} Monde fromJSON(JSONObject, String)
            + int intLePlusProche(int, int)
            + Graph<Point2D, DefaultEdge> grapheAlternatif(Monstre, int)
            + void heroAttaque()
            + void deplacementHeros(TypeMouvement, double)
            + void deplacementMonstres()
            + void deplacementMonstre(Monstre, double)
            + void pathfinding(Monstre, int, Graph<Point2D, DefaultEdge>, Point2D, Point2D, double)
            + TypeMouvement getMouvement(Point2D, Point2D, Monstre)
            + void mouvementRandom(Monstre, double)
            + boolean collisionAvec(Personnage, boolean)
            + boolean collisionAvecTerrains(Personnage)
            + void heroRamassageObjet()
            # boolean collision(ElementMonde, ElementMonde)
            - void chargerCarte(String)
        }
    }

    package gui {
        class Sprite
    }

    package engine {
        abstract class GameController
    }

    class SaveData {
        - String filename
        - JSONObject json
        ..Constructeur..
        + SaveData(Map.Entry<String, JSONObject>)
        ..Méthodes..
        + String getDate()
        + double getLife()
        + int getLevel()
        + void deleteFromFS()
    }

    class Settings {
        - {static} PropertyChangeSupport pcs
        + {static} Property<Boolean> fullScreen
        + {static} Property<Boolean> showFps
        + {static} Property<Locale> locale
        ..Méthodes..
        + {static} void reset()
        + {static} void load()
        + {static} void save()
        - {static} boolean ensureSettingsFileExists()
        - {static} void initAutoSave()
    }

    class "Property <T> " as Property {
        - T value
        - String name
        - Map<MyPropertyChangeListener<T>, PropertyChangeListener> listeners
        - PropertyChangeSupport pcs
        - boolean log
        ..Constructeur..
        + Property(PropertyChangeSupport, String, T, Getter<T>, Setter<T>)
        + Property(T, Getter<T>, Setter<T>)
        + Property(PropertyChangeSupport, String, T)
        + Property(T)
        ..Méthodes..
        + T get()
        + void set(T)
        + void subscribe(MyPropertyChangeListener<T>)
        + void subscribeIfNot(MyPropertyChangeListener<T>)
        + void unsubscribe(MyPropertyChangeListener<T>)
        + void unsubscribeAll()
        + void forceFire()
        + Property<T> setLog(boolean)
        - void fire(T)
        - void log(String)
    }

    interface "Getter <T> " as Getter {
        T get(T)
    }

    interface "Setter <T> " as Setter {
        T set(T)
    }
}

' notes
note "Voir diagramme <i>class-gui</i> pour en savoir plus\nsur ces packages et les classes qu'ils contiennent." as N_gui
N_gui .left. engine
N_gui .. gui

note "'Type type' : Uniquement pour\nla sérialisation en JSON." as N_json
N_json ... ElementMonde::Type


' elements monde
'Personnage ----"*" Escape.gui.Sprite
'Terrain --"1" Escape.gui.Sprite
'Objet --"1" Escape.gui.Sprite
ElementMonde ---"*" Escape.gui.Sprite

Personnage --"2" TypeMouvement : + orientation

Personnage -up--|> ElementMonde
Terrain -up--|> ElementMonde
Objet -up--|> ElementMonde
Escape.Monde.Monde --- "*" Personnage
Escape.Monde.Monde --- "*" Terrain
Escape.Monde.Monde --- "*" Objet


' settings
Settings -- Property
Property --"1" Getter
Property --"1" Setter


GameController -- "1" Escape.Monde.Monde


@enduml
